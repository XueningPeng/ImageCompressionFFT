"""
Final.py
Name: Xuening Peng
Date: 22/04/2022
"""

import numpy as np
import matplotlib.pyplot as plt
import urllib.request
from PIL import Image

# Load images with URL for processing
urllib.request.urlretrieve('http://introdh.dahvc.org/omeka/files/original/61/girl.jpg', 'girl')
A = Image.open('girl')
B = np.mean(A, axis=-1)  # Convert RGB to grayscale by calculating means of RGB values respectively

# Start image compression
Bt = np.fft.fft2(B)  # fft the image from pixels to frequency
Btsort = np.sort(np.abs(Bt.reshape(-1)))  # flatten and sort the frequency by magnitude

# the compressed_img function takes in "percent", to keep the "percent" percentage of high frequency coefficients of fft
# the output is the compressed image generated by the inverse fft
# by keeping "percent" percentage of high frequency coefficients of fft
def compressed_img(percent):
    thresh = Btsort[int(np.floor((1 - percent) * len(Btsort)))]  # Create threshold to
    i = np.abs(Bt) > thresh  # Find small indices
    Btlow = Bt * i  # Zero out low frequency pixels
    Alow = np.fft.ifft2(Btlow).real
    # then do the inverse of fast fourier transform with "percent" percentage of frequency kept, keep the real part
    return Alow


if __name__ == "__main__":
    """ Section 1. Show original image"""
    plt.figure()
    plt.imshow(A)
    plt.axis('off')
    # plt.show()
    plt.savefig("Original img")
    plt.clf()

    """Section 2. Calculate the 2D image fft"""
    a = np.fft.fft2(B)  # implementing fft2 for 2D image transform (both row-wise and column-wise)
    b = np.fft.fftshift(a)  # Shift zero-frequency component to the center of the spectrum
    final = np.log(abs(b))
    # the dynamic range of the Fourier coefficients is too large
    # to be displayed on the screen, all other values will be black
    # therefore, use np.log() helps better view the pixel-based fft of the image

    plt.subplot(121)
    plt.imshow(B)
    plt.axis("off")
    plt.subplot(122)
    plt.imshow(final, cmap='gray')
    plt.axis("off")
    # plt.show()
    plt.savefig("fft of the grayscale img")
    plt.clf()

    """Section 3. Compressed images by keeping 0.1, 0.05, 0.01, 0.002 percent of the fourier coefficients"""
    plt.figure()
    plt.subplot(221)
    plt.imshow(compressed_img(0.1), cmap='gray')
    plt.axis("off")
    plt.title('keep = ' + str(0.1 * 100) + '%')

    plt.subplot(222)
    plt.imshow(compressed_img(0.05), cmap='gray')
    plt.axis("off")
    plt.title('keep = ' + str(0.05 * 100) + '%')

    plt.subplot(223)
    plt.imshow(compressed_img(0.01), cmap='gray')
    plt.axis("off")
    plt.title('keep = ' + str(0.01 * 100) + '%')

    plt.subplot(224)
    plt.imshow(compressed_img(0.002), cmap='gray')
    plt.axis("off")
    plt.title('keep = ' + str(0.002 * 100) + '%')
    # plt.show()
    # plt.close()
    plt.savefig("compressed imgs with i coefficients kept")
    plt.clf()

    """Section 4. Draw the surface Plot of grayscale image"""
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    X, Y = np.meshgrid(np.arange(1, np.shape(B)[1] + 1), np.arange(1, np.shape(B)[0] + 1))
    ax.plot_surface(X[0::10, 0::10], Y[0::10, 0::10], B[0::10, 0::10], cmap='plasma')  # Configure the 3D surface plot
    ax.set_title('Surface plot of girl img')
    ax.mouse_init()  # can adjust viewing angles by mouse
    ax.view_init(200, 270)  # initial view is set to front
    plt.show()
